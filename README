Mihai Gherghina
Nicholas Sheffler       Assignment 5

How we started:
We started by rereading the paper to get a better understanding of what was going on as there were still parts of it that we didn’t fully understand yet. Then we took your advice from class and attempted to play with the Sketch portion of the paper.

What we did:
At first we didn't really have any direction with the project. We attempted to focus on section 2 and 4 of the paper and understand the real backend working of the sketch itself.  It was incredibly hard to find sketch online as most of the Mit and Berkley links that were present in various papers we were reading carried dead links. It wasn’t until we found J-Sketch that we started to make some headway. After posting on the piazza about J-Sketch, someone else offered a better Sketch  As noted on Piazza we fell into source compiling errors on various versions that we had found online.  At first Nick was unable to compile on WSL and Windows, so I attempted compiling on ubuntu.  Having installed all the necessary dependencies (bison,flex,gcc,etc.) I was running into fatal errors at the make stage.  Spending some time and asking online, we came to the conclusion that gcc was actually the problem and there was an error with versions 4.5+.  It was noted that we should use gcc 4.3 but that was hard to find. After some searching we came across a link that carried a newer version of sketch (v1.6.5).  Hopeful that this would compile, we ran into new errors relating to the make process. We took it upon ourselves to post to piazza a link with the most recent version of Sketch that we could find, in the hopes that someone could make it work and describe their process.   We then found the newest version (v1.7.5) and downloaded.  It took about 30 minutes to compile the backend, and then another 15 minutes to compile the frontend.  

After having finally compiled we started playing around with the given tests, specifically miniTest1.sk in the test/sk/seq folder.  We first ran sketch normally just to see the output , it showed us nothing.  After reading more of the manual we started running sketch with verbose flags (level 3 and 5) , we also were able to run sketch with --fe-output-code which provided some useful information as its output was the C++ implementation, and generated a .cpp and .h file.  We also ran --fe-output-test and looked at the generated test harness of the code to run on multiple inputs.  All in all I wish we had a centralized machine that would have worked from the beginning with sketch because it was very time consuming to find and get it to work. We attempted to rewrite the compute derivative function from the paper with running the --debug-cex and verbosity level at 3 so that we could see the counterexamples that were given, but were running into implementation issues with sketch again, and we had run past 5 hours at this point to make it work.   


What we learned:
After a lot of playing around with the Sketch program, we learned that the Sketch program was a powerful SAT solver that could find complex answers including arrays and structures. We went through quite a lot of the tests to gain this understanding. We also learned that maybe it would be best to ask on piazza what others had found in order to help expedite the process of working on these papers, especially since these papers seem to lack links to their code. We also learned that while SATs are powerful, there was a lot of work that went into this paper to get the mpy to become sk files as we tried to replicate this but quickly realized that the dynamic typing of python didn’t translate simply to the sketch language. From the way that Sketch works, it makes sense that each student’s file would have produced multiple sk files in order to determine what would be the best feedback for their program rather than just a complete makeover of what they had written. 


We have attached the outputs of the commands that we stated above in our github. 

